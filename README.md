# FP-lab-1


Функциональное программирование<br>
Отчет по лабораторной работе №1


**Выполнил:** <br>
Ефремов Марк Андреевич

**Группа:**<br>
P3334

**Преподаватель:**<br>
Пенской Александр Владимирович


**Проблема 4**

https://projecteuler.net/problem=4<br>
Найти наибольшее число-палиндром, являющееся произведением двух трёхзначных чисел.

**Реализация:**

Перебор пар трёхзначных чисел I и J со следующими оптимизациями:
- Перебор от наибольших значений к наименьшим
- Умножение коммутативно, можно рассматривать J < I
- Если найдена пара I1 и J, такая, что I1*J1 – палиндром, то, переходя к дальнейшим итерациям, где I2, можно рассматривать только J < J1.

Реализации:
- [С простой рекурсией](./src/problem1/solution1.ml)
- [С хвостовой рекурсией](./src/problem1/solution2.ml)
- [С модульной реализацией](./src/problem1/solution3.ml)
- [С map-генерацией](./src/problem1/solution4.ml)
- [С синтаксисом для циклов](./src/problem1/solution5.ml)
- [С ленивой коллекцией](./src/problem1/solution6.ml)
- [Реализация на Python](./src/problem1/solution7.ml)

![image](https://github.com/user-attachments/assets/5f159c78-4fd9-4329-b425-e8776c1e061b)


**Выводы:**

Во время работы с обычной рекурсией получал переполнение стека, в то время, как хвостовая рекурсия оптимизируется компилятором. Для проверки того, является ли рекурсия хвостовой, была использована аннотация `@tailcall`, но убрана из кода ради читабельности. 

Модульная реализация с использованием последовательностей становится очень компактной за счёт оператора конвеерной обработки. Однако он требует написания большого количества лямбда-функций, которые засоряют код. Также, сложнее было применить вышеописанные оптимизации, поэтому модульная реализация оказалась очень медленной. 

Реализация с ленивой коллекцией (Seq) полностью совпадает с “map-generated”, и также получилась медленной.  


<br>
**Проблема 27**

https://projecteuler.net/problem=27
Найти произведение чисел a и b, таких, что при подстановке в формулу
n2+an+b последовательных значений n от 0, она даёт наибольшее количество простых чисел. 

**Реализация:**

Перебор пар трёхзначных чисел a и b со следующими оптимизациями:
- при n=0, n2+an+b = b, должно быть простым числом. Вывод – b должно быть простым.
- при n=1, n2+an+b = 1 + a + b. А значит, чтобы число получилось простым, у a и b должна быть разная чётность.

Реализации:
- [С простой рекурсией](./src/problem2/solution1.ml)
- [С хвостовой рекурсией](./src/problem2/solution2.ml)
- [С модульной реализацией](./src/problem2/solution3.ml)
- [С map-генерацией](./src/problem2/solution4.ml)
- [С синтаксисом для циклов](./src/problem2/solution5.ml)
- [С ленивой коллекцией](./src/problem2/solution6.ml)
- [Реализация на Python](./src/problem2/solution7.ml)

![image](https://github.com/user-attachments/assets/c7081046-bd5f-446b-a2e1-013b5e7d66a5)


**Выводы:**

В данном случае обычную рекурсию было сделать сложнее, чем хвостовую. 

Благодаря мутабельным полям record, а также синтаксису для циклов, на Ocaml можно написать решение, полностью аналогичное решению на Python. Однако этот язык не предоставляет аналогов для “break” и “continue”, что значительно ограничивает возможности работы с циклами.  

Генерация последовательности с помощью map - решение, которое для первой проблемы было самым медленным, для второй оказалось самым быстрым. Я предполагаю, что это связано с тем, что я применил фильтрацию на всех этапах формирования последовательности.
